<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://raiseyang.github.io</id>
    <title>指南针在摇摆</title>
    <updated>2022-02-15T05:24:54.074Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://raiseyang.github.io"/>
    <link rel="self" href="https://raiseyang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://raiseyang.github.io/images/avatar.png</logo>
    <icon>https://raiseyang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 指南针在摇摆</rights>
    <entry>
        <title type="html"><![CDATA[Gradle 常用任务]]></title>
        <id>https://raiseyang.github.io/post/gradle-chang-yong-ren-wu/</id>
        <link href="https://raiseyang.github.io/post/gradle-chang-yong-ren-wu/">
        </link>
        <updated>2022-01-21T07:33:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="gradlew-version">gradlew --version</h2>
<p>查看当前 Gradle 版本信息<br>
<img src="https://raiseyang.github.io/post-images/1642750911927.png" alt="" loading="lazy"></p>
<h2 id="gradlew-tasks">gradlew tasks</h2>
<p>通常在 Android Studio中，我们可以通过面板，直接运行 Gradle 任务；<br>
<img src="https://raiseyang.github.io/post-images/1642750611309.png" alt="" loading="lazy"></p>
<p>但是在某些场景下，我们还是需要自己手动敲击命令行来执行任务；比如上面那个面板异常了，或者是想同时执行多个任务了；<br>
<code>gradlew tasks</code>可以列出当前所有可执行的 Gradle 任务；解决了我们在命令行敲任务名称时，老是记不住的问题；</p>
<h2 id="gradlew-appdependencies">gradlew app:dependencies</h2>
<p>依赖树查询<br>
所以官方又推出了Scan工具来帮助我们更加方便地查看依赖树<br>
在项目根目录位置下运行gradle build --scan即可，然后会生成 HTML 格式的分析文件的分析文件<br>
分析文件会直接上传到Scan官网，命令行最后会给出远程地址<br>
第一次跑会让你在 Scan 官网注册一下，邮件确认后就能看了<br>
scan 工具是按照依赖变体挨个分类的，debugCompileClassPath 就是 dedug 打包中的依赖包了</p>
<hr>
<h2 id="参考">参考</h2>
<p><a href="https://juejin.cn/post/6947675376835362846">7个你应该知道的Gradle实用技巧</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OMA DM Notifications-V1.2.1]]></title>
        <id>https://raiseyang.github.io/post/oma-dm-notifications-v121/</id>
        <link href="https://raiseyang.github.io/post/oma-dm-notifications-v121/">
        </link>
        <updated>2022-01-20T06:44:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>Notifications 定义：服务器<strong>推送</strong>一条消息给客户端，客户端接收到这条<strong>消息</strong>，并使用这条消息。<br>
这里的推送可以使 WAP PUSH, 也可以是 MQTT 等方式；<br>
消息也是有具体定义的，官方文档重要的讲述了消息的格式；</p>
<h2 id="消息格式">消息格式</h2>
<p>先上2张官方文档的格式图：<br>
<img src="https://raiseyang.github.io/post-images/1642661385945.png" alt="消息格式" loading="lazy"><br>
<img src="https://raiseyang.github.io/post-images/1642661394683.png" alt="格式说明" loading="lazy"></p>
<h2 id="实战">实战</h2>
<p>某服务器下发的通知消息如下：<br>
<img src="https://raiseyang.github.io/post-images/1642661603869.png" alt="" loading="lazy"></p>
<p>digest算法<br>
Digest = H(B64(H(serveridentifier:password)):nonce:B64(H(trigger)))</p>
<h2 id="参考">参考</h2>
<p>1。OMA-TS-DM_Notification-V1_2_1-20080617-A.pdf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[油猴脚本 将网站拷贝成 Markdown 格式的链接]]></title>
        <id>https://raiseyang.github.io/post/zi-ji-de-you-hou-jiao-ben/</id>
        <link href="https://raiseyang.github.io/post/zi-ji-de-you-hou-jiao-ben/">
        </link>
        <updated>2022-01-19T09:02:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="将网站拷贝成-markdown-格式的链接">将网站拷贝成 Markdown 格式的链接</h2>
<h3 id="起因">起因：</h3>
<p>每次写 Blog 时，需要参考互联网上的文章，参考完成之后，希望能够把链接拷贝到文章里，这样一方面方便自己以后仔细的对照，一方面也尊重作者的成果；<br>
在每次拷贝文章的时候，我都是去浏览器地址栏拷贝；很方便，鼠标点击一下地址栏(或者快捷键 <code>Ctrl + L</code>)，<code>Ctrl + C</code>就成了；<br>
但是这样的纯链接贴到 .md 文件中，还是一个链接，并没有按照 .md 格式<code>[百度一下](https://www.baidu.com)</code>，而且不方便阅读；<br>
更优秀的方式，是拷贝之后，直接贴过来，就已经包含了 .md 格式；<br>
比如要参考该篇 Blog<br>
<img src="https://raiseyang.github.io/post-images/1642583702475.jpg" alt="" loading="lazy"><br>
如果直接拷贝链接<br>
https://blog.csdn.net/u011054333/article/details/104101806</p>
<p>拷贝成 .md 格式的链接<br>
<a href="https://blog.csdn.net/u011054333/article/details/104101806">油猴脚本编写教程</a><br>
可读性大大增加；<br>
而且还有一个好处是，如果后面某些原因这篇文章链接打不开了，我们还可以百度文章标题，基本上会出现一大波&quot;<strong>抄袭</strong>&quot;文章；</p>
<h3 id="需求">需求：</h3>
<p>很明确，希望在界面是显示一个按钮，点击一下会将文章标题和链接拷贝成 .md 的格式；</p>
<h3 id="分析">分析</h3>
<p>该功能可以通过浏览器扩展，油猴脚本来实现；很明显油猴脚本对这种小需求更适合；所以我采用油猴脚本实现；<br>
首先需要找到文章标题，文章链接，通过查看网页源码查找<br>
<img src="https://raiseyang.github.io/post-images/1642584371647.png" alt="" loading="lazy"><br>
<s>使用 JQuery 找到这两个元素；</s><br>
文章链接通过 window.location.href 得到；<br>
文章标题通过 $(&quot;#articleContentId&quot;).text(); 得到；</p>
<p>在页面上添加一个按钮，并绑定点击事件；<br>
可参考 https://blog.csdn.net/u010598445/article/details/108880602</p>
<p>文本复制到剪切板<br>
https://www.tampermonkey.net/documentation.php#GM_setClipboard</p>
<h3 id="实现">实现</h3>
<p>稍微改动一下，做成悬浮的，左上角显示；方便点击；</p>
<pre><code>// ==UserScript==
// @name         复制成 Markdown 的 Link
// @namespace    https://raiseyang.github.io/
// @version      0.1
// @description  将当前网站链接拷贝成 Markdown 格式
// @author       RaiseYang
// @include        *
// @match        https://blog.csdn.net/**
// @icon         https://raiseyang.github.io/raiseyang/markdown_copy.png
// @grant        GM_setClipboard
// @require     https://cdn.bootcss.com/jquery/2.1.2/jquery.min.js
// @license        MIT
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
    var $ = window.$;

    console.log('复制成 Markdown 的 Link 脚本加载了');
    var button = document.createElement(&quot;button&quot;); //创建一个input对象（提示框按钮）
    button.id = &quot;id001&quot;;
    button.textContent = &quot;Markdown Link&quot;;
    button.style.background=&quot;red&quot;;
    button.style.width = &quot;100px&quot;;
    button.style.height = &quot;40px&quot;;
    button.style.position = &quot;fixed&quot;;
    button.style.bottom = &quot;100px&quot;;
    button.style.right = &quot;20px&quot;;

    //绑定按键点击功能
    button.onclick = function (){
        console.log('点击了按键');

        // 当前网站链接
        var link = window.location.href

        let title;

        let CSDNegexp= /.*csdn\.net\/.+/; // 匹配CSDN
        if(CSDNegexp.test(link)){
            console.log(&quot;CSDNegexp&quot;)

            title = $(&quot;#articleContentId&quot;).text(); // CSDN的title定制化
        }else {
            console.log(&quot;other site&quot;)
            title = $(document).attr('title');
        }

        //alert(&quot;[&quot;+title+&quot;](&quot;+link+&quot;)&quot;);
        let markdownLink = &quot;[&quot;+title+&quot;](&quot;+link+&quot;)&quot;; // 拼接成Markdown格式
        GM_setClipboard(markdownLink, &quot;text&quot;); // 复制到剪切板
        console.log('GM_setClipboard='+markdownLink); // 控制台打印，便于调试
        return;
    };

    $(&quot;body&quot;).append(button); // 添加button按钮

})();
</code></pre>
<h2 id="放在-greasyfork-上">放在 greasyfork 上</h2>
<p>在 <a href="https://greasyfork.org/zh-CN">greasyfork</a> 上先注册一个账号，然后可以很方便的上传自己的脚本；<br>
本文的脚本地址是：<a href="https://greasyfork.org/zh-CN/scripts/438841-%E5%A4%8D%E5%88%B6%E6%88%90-markdown-%E7%9A%84-link">复制成 Markdown 的 Link</a></p>
<p>参考：<br>
<a href="https://blog.csdn.net/feiying0canglang/article/details/114235964">油猴--基础</a><br>
<a href="https://www.tampermonkey.net/documentation.php?ext=dhdg">Tampermonkey • 文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OMA DM Bootstrap]]></title>
        <id>https://raiseyang.github.io/post/oma-dm-bootstrap/</id>
        <link href="https://raiseyang.github.io/post/oma-dm-bootstrap/">
        </link>
        <updated>2022-01-18T05:52:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概念">概念</h2>
<p>Bootstrap ，中文翻译为引导程序，就是我们一个成熟的 Client 程序开发好了，也烧在 Android 手机上了，但是缺少运行的<strong>必要信息</strong> (profile)，所以这个 Client 是不能运行的。<br>
需要将这些<strong>必要信息</strong> <strong>导入</strong>到 Android 手机上，Client 才能正常运行；<br>
上面提到的必要信息包括：DM 服务器信息(url，认证信息)等；<br>
<strong>导入</strong>分为 3 种导入方式：1，客制化引导(工厂引导)；2，服务器引导；3，智能卡引导</p>
<h2 id="oma-cpdm">OMA CP/DM</h2>
<p>OMA CP 和OMA DM是两种可选的<strong>必要信息</strong>；<br>
OMA CP 用于使用 OMA 配置一些邮箱，WIFI 等信息；<br>
OMA DM 用于使用 OMA DM 做一些设备管理；</p>
<h2 id="使用场景">使用场景</h2>
<p>Bootstrap 的目的想让 Client 有连接多个服务器的能力，比如在开发初期，在国内测试时，一般都需要配置自己的 DM 服务器地址，在中途做 IOT 测试时，需要访问 IOT DM 服务器，在项目后期，又要切换到需求方的服务器；<br>
可能起初制定方案的时候，想的很多，但现在大家实现的 Client 基本都是工厂引导，将几个服务器地址都提前配置到 Client 中，通过一些特殊操作来切换；</p>
<h2 id="现状">现状</h2>
<p>根据目前需求方的情况，只需要<strong>工厂引导</strong>即可；<br>
也就是提前做好 DM Tree 文件配置，然后将 DM Tree 文件放在 APK 里；<br>
关于 DMACC 节点，一般都是提前写在 DM Tree 中；</p>
<p>OMA CP 也没有需求方需要，可以不用看；</p>
<h2 id="参考">参考</h2>
<p>1.<a href="/static/OMA-TS-DM_Bootstrap-V1_2_1-20080617-A.pdf">OMA-TS-DM_Bootstrap-V1_2_1-20080617-A.pdf</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OMA DM 资源汇总]]></title>
        <id>https://raiseyang.github.io/post/oma-dm-zi-yuan-hui-zong/</id>
        <link href="https://raiseyang.github.io/post/oma-dm-zi-yuan-hui-zong/">
        </link>
        <updated>2022-01-17T06:58:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="官方资料">官方资料</h2>
<p><a href="https://technical.openmobilealliance.org/index.html">OMA Specifications（技术文档官网）</a></p>
<blockquote>
<p>里面包含所有 OMA 定义的标准文档列表；可根据自己感兴趣的资料点进去进行下载。</p>
</blockquote>
<p>下面列出一些常用的标准文档下载地址：</p>
<blockquote>
<p>注意：*-A 结尾的版本代表正式版，直接下载 -A 结尾的就行了；</p>
</blockquote>
<p><a href="https://www.openmobilealliance.org/release/Common/">OMA SyncML Common Specification</a></p>
<blockquote>
<p>SyncML 协议相关文档</p>
</blockquote>
<p><a href="https://www.openmobilealliance.org/release/DM">OMA Device Management (DM)</a></p>
<blockquote>
<p>DM 协议相关文档</p>
</blockquote>
<p><a href="https://www.openmobilealliance.org/release/FUMO/">OMA Firmware Update Management Object</a></p>
<blockquote>
<p>OTA 升级相关文档</p>
</blockquote>
<h2 id="开源资料">开源资料</h2>
<h3 id="funambol-服务器">Funambol 服务器</h3>
<blockquote>
<p>目前找到唯一开源的 OMA DM 相关的服务器，作为调试使用，能够满足正常需求；</p>
</blockquote>
<p><a href="https://pan.baidu.com/s/1GM3ZHvp62pYwAkiJYz0Gyg?pwd=tg1a">点我下载 funambol-packages.zip</a></p>
<p>部署环境：<br>
JDK:1.8<br>
MySQL:5.7.17<br>
Jboss:3.2.6</p>
<p>部署步骤：</p>
<ol>
<li>将部署环境都安装好；MySQL 和 Jboss 需要通过 JDBC 联通；配置好 JBOSS_HOME，J2EE_HOME环境变量；运行 Jboss，可访问 http://localhost:8080/ （ Jboss 环境配好后，关闭 Jboss，以免影响后面操作）</li>
<li>创建 funambol 数据库</li>
</ol>
<pre><code>mysql &gt; create database funambol_db;
mysql &gt; grant all on funambol_db.* to 'funambol'@'localhost' identified by 'funambol';
</code></pre>
<ol start="3">
<li>funambol 服务配置</li>
</ol>
<pre><code>Funambol/install.properties配置

server-name=http://127.0.0.1:8080/funambol/dm
dbms=mysql
jdbc.classpath=D:/jboss-3.2.6/MySQLJDBC/mysql-connector-java-5.1.7-bin.jar
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1/funambol_db?zeroDateTimeBehavior=round
jdbc.user=funambol
jdbc.password=funambol

Funambol/default/config/common/properties/Funambol.properties配置

server.uri=http://127.0.0.1:8080/funambol/dm
syncml.dtdversion=1.2
engine.manifacturer=Funambol
engine.modelname=DM Server

</code></pre>
<ol start="4">
<li>执行 Funambol 源码下的 <code>&quot;.\Funambol\bin\install.cmd&quot;</code>, 生成数据库信息</li>
<li>开启 Jboss，执行 Funambol 源码下的 <code>&quot;.\Funambol\bin\start.cmd&quot;</code>, 启动服务，访问http://127.0.0.1:8080/dmdemo/</li>
</ol>
<h3 id="scts_dm_112">SCTS_DM_1.1.2</h3>
<blockquote>
<p>目前找到唯一可用的测试客户端，可以用来调试服务器协议支持情况；</p>
</blockquote>
<p>下载地址 https://sourceforge.net/projects/oma-scts/</p>
<p>使用步骤：<br>
<img src="https://raiseyang.github.io/post-images/1642405871811.png" alt="" loading="lazy"><br>
<img src="https://raiseyang.github.io/post-images/1642405930057.png" alt="" loading="lazy"></p>
<blockquote>
<p>注意客户端认证：用户名和密码都填写 funambol</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://raiseyang.github.io/post-images/1642405935360.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.mk 文件基础]]></title>
        <id>https://raiseyang.github.io/post/mk-wen-jian-ji-chu/</id>
        <link href="https://raiseyang.github.io/post/mk-wen-jian-ji-chu/">
        </link>
        <updated>2021-03-24T05:39:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="依赖jar包">依赖jar包</h2>
<p>先声明<br>
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := moduleName:libs/xxx.jar <br>
moduleName2:libs/xxx2.jar <br>
再使用<br>
LOCAL_STATIC_JAVA_LIBRARIES := moduleName<br>
moduleName2 \</p>
<h2 id="如何依赖aar">如何依赖aar</h2>
<p>先声明<br>
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := widget-项目名:路径/widget.aar<br>
再使用<br>
LOCAL_STATIC_JAVA_AAR_LIBRARIES := widget-项目名<br>
给aar添加包名<br>
LOCAL_AAPT_FLAGS := --auto-add-overlay <br>
--extra-packages android.support.v7.appcompat \</p>
<p>aar和jar一样的依赖方式;</p>
<h2 id="配置assets目录">配置assets目录</h2>
<p>LOCAL_ASSET_DIR := $(LOCAL_PATH)/app/src/main/assets</p>
<h2 id="配置resource">配置resource</h2>
<p>LOCAL_RESOURCE_DIR := <br>
$(addprefix $(LOCAL_PATH)/../../library/yxp_src/dictenginelib/, res) <br>
$(LOCAL_PATH)/res</p>
<h2 id="配置源码">配置源码</h2>
<p>LOCAL_SRC_FILES := $(call all-java-files-under, src) <br>
src/com/noahedu/synclearning/engine/IBookService.aidl <br>
src/com/noahedu/synclearning/engine/IBookServiceCallback.aidl</p>
<h1 id="call-all-java-files-underextrafunctionsrcmainjava"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>−</mo><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mo>−</mo><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>−</mo><mi>u</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">(call all-java-files-under,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span></span></span></span>(extrafunction)/src/main/java)\</h1>
<p>#需要引入library/aar的包名<br>
LOCAL_AAPT_FLAGS := --auto-add-overlay <br>
--extra-packages com.noahedu.DictEngine <br>
--extra-packages android.support.v7.appcompat <br>
--extra-packages android.support.constraint <br>
--extra-packages android.support.v7.recyclerview \</p>
<h1 id="是赋值的意思是追加的意思表示连接符">‘:=’是赋值的意思；’+=’是追加的意思；‘\’表示连接符。</h1>
<p>LOCAL_MODULE_TAGS :=user eng tests optional</p>
<ul>
<li>user: 指该模块只在user版本下才编译</li>
<li>eng: 指该模块只在eng版本下才编译</li>
<li>tests: 指该模块只在tests版本下才编译</li>
<li>optional:指该模块在所有版本下都编译</li>
</ul>
<p>#指定arm目录<br>
LOCAL_PREBUILT_JNI_LIBS_arm := libs/armeabi-v7a/libdecrypt.so <br>
libs/armeabi-v7a/liblasa.so <br>
libs/armeabi-v7a/libspeex.so \</p>
<p>#指定androidmainfest.xml目录<br>
LOCAL_MANIFEST_FILE := app/src/main/AndroidManifest.xml</p>
<p>#########################################</p>
<h2 id="以apk方式引用">以apk方式引用</h2>
<p>#########################################<br>
LOCAL_PATH := $(my-dir)</p>
<p>include $(CLEAR_VARS)<br>
LOCAL_MODULE        := ${moduleName}<br>
LOCAL_MODULE_TAGS   := optional<br>
LOCAL_MODULE_CLASS  := APPS<br>
LOCAL_CERTIFICATE   := platform<br>
LOCAL_DEX_PREOPT := false<br>
LOCAL_MODULE_SUFFIX := .apk<br>
LOCAL_MODULE_PATH   := $(PRODUCT_OUT)/system/app<br>
LOCAL_SRC_FILES     := $(LOCAL_MODULE).apk<br>
include $(BUILD_PREBUILT)</p>
<h2 id="参考">参考</h2>
<pre><code>1. https://blog.csdn.net/hegan2010/article/details/88710201
2. https://www.jianshu.com/p/63715928063b
3. LOCAL_PRIVILEGED_MODULE 详解 https://blog.csdn.net/zhanglianyu00/article/details/75099025
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小 APK 编译实战]]></title>
        <id>https://raiseyang.github.io/post/zui-xiao-apk-bian-yi-shi-zhan/</id>
        <link href="https://raiseyang.github.io/post/zui-xiao-apk-bian-yi-shi-zhan/">
        </link>
        <updated>2020-06-20T07:31:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="最小启动-apk-大小实践">最小启动 APK 大小实践</h1>
<p>在做 APK 文件的瘦身的实践中，为了了解清楚 APK 文件中到底哪些是必须的，哪些是可以删除的，特地做了本次实践。</p>
<h2 id="使用-android-studio-创建新项目">使用 Android Studio 创建新项目</h2>
<p>平时开发，我们都是从 Android Studio 新建项目开始，不断的编码，丰富 APK 功能；自然 APK 的文件越来越大。<br>
这里我们试试当创建一个新项目时，不加任何自己的代码，编译生成一个 APK 的内容和大小；<br>
环境：<code>AndroidStudio 4.0</code><br>
1.默认生成 APK 大小：<strong>2.2M</strong><br>
<img src="https://raiseyang.github.io/post-images/1643009641954.png" alt="" loading="lazy"></p>
<p>参考上图，<code>classes.dex</code> 文件占用空间最大，占比 79.3%；再进一步选中后，发现 androidx 相关库的代码占用 1.5M；<br>
我们知道 androidx 是 google 的扩展框架，不是一个 APK 文件必须的，所以可以去掉相关依赖；</p>
<pre><code>去除androidx：
ConstraintLayout使用LinearLayout代替
Theme.AppCompat.Light.DarkActionBar使用android:Theme.Black.NoTitleBar代替
AppCompatActivity使用Activity代替
</code></pre>
<p>2.去除 androidx 库后的APK大小：<strong>1.2M</strong></p>
<p><img src="https://raiseyang.github.io/post-images/2.png" alt="" loading="lazy"><br>
最大文件依然是<code>classes.dex</code>，这次是 kotlin 相关库占用955.1KB。<br>
kotlin 也是 google 后期进入的，可以去除，使用 Java 代替。</p>
<pre><code>去除kotlin:
删除kotlin相关gradle插件，依赖
MainActivity.kt替换为MainActivity.java
</code></pre>
<p>3.去除 kotlin 相关库后的 APK 大小：<strong>90.4K</strong></p>
<p><img src="https://raiseyang.github.io/post-images/3.png" alt="" loading="lazy"><br>
去除 androidx 和 kotlin 后，APK 大小仅为 90.4K，比原来的 2.2M, 减少了近 96% 大小；<br>
目前占比最大的是 res/ 下的文件，这里面都是使用到的常量资源: icon（应用图标，APK 可以不配置图标），activity.xml（activity 的布局文件，可以使用 View 对象代替），可以全部去除；</p>
<pre><code>去除res/:
直接删除res目录下所有文件
setContentView(new View(this));
</code></pre>
<p>4.去除 res 资源文件目录后的 APK 大小：<strong>7.7K</strong><br>
<img src="https://raiseyang.github.io/post-images/4.png" alt="" loading="lazy"><br>
如上图，占比最大的是 MEAT-INF，这是 V1 签名的相关内容，暂时先不优化；<br>
点进 <code>classes.dex</code> 发现 BuildConfig 这个类，这个类是 Android Studio 在编译时自动生成的，程序中可以不适用，所以可以去除；</p>
<pre><code>去除BuildConfig:
// 在build.gradle中配置
android.applicationVariants.all { variant -&gt;
    variant.generateBuildConfig.enabled = false
}
</code></pre>
<p>5.去除 BuildConfig 后的 APK 大小：7.6K</p>
<p><img src="https://raiseyang.github.io/post-images/5.png" alt="" loading="lazy"><br>
如上图，AndroidManifest.xml 占比较大，考虑将该文件内的内容优化；</p>
<pre><code>//将Activity申明简化，后续使用adb命令启动
//注意一定要配置android:exported=&quot;true&quot;，不然adb不能启动界面
    &lt;application&gt;
        &lt;activity
            android:exported=&quot;true&quot;
            android:name=&quot;.MainActivity&quot; /&gt;
    &lt;/application&gt;
</code></pre>
<p>6.优化清单文件后，APK 的下载大小：3.4K</p>
<p><img src="https://raiseyang.github.io/post-images/6.png" alt="" loading="lazy"><br>
MEAT-INF 文件夹下，主要包含 V1 签名信息，可以考虑去除 V1 签名信息文件；仅使用 V2 签名，生成的 APK 文件仅可安装于 Android 7.0 及之后的系统中。</p>
<pre><code>//去除V1签名，配置签名时
    signingConfigs {
        signV2 {
            storeFile file(&quot;../sign.jks&quot;)
            storePassword &quot;xxx&quot;
            keyAlias &quot;xxx&quot;
            keyPassword &quot;xxx&quot;
            v1SigningEnabled false
            v2SigningEnabled true
        }
    }
</code></pre>
<p>7.去除 V1 签名信息后，APK 的下载大小仅 2.7K；<br>
<img src="https://raiseyang.github.io/post-images/8.png" alt="" loading="lazy"></p>
<h2 id="使用-build-tools-工具编译生成-apk">使用 Build Tools 工具编译生成 APK</h2>
<p>根据上一小节经验，我们将 app 目录下的资源单独拷贝出来，用作源码，使用安卓的 SDK 构建工具集，就可以编译生成 APK；</p>
<blockquote>
<p>这个 APK 也包含四个部分：</p>
<ol>
<li>resources.arsc</li>
<li>classes.dex</li>
<li>AndroidManifest.xml</li>
<li>META-INF</li>
</ol>
</blockquote>
<ol>
<li>编译资源文件，生成 resources.arsc<br>
<code>aapt2 compile --dir app/src/main/res/ -o package/res.zip</code></li>
</ol>
<ul>
<li>--dir 指定资源路径</li>
<li>-o 指定输出路径</li>
</ul>
<p>编译完成后，会在 package 文件夹下看到 res.zip 这个文件；可以尝试解压看看里面内容；</p>
<ol start="2">
<li>连接 manifest.xml 文件，生成 R 文件，生成初步 apk 文件<br>
<code>aapt2 link package/res.zip -I D:/android-sdk-windows/platforms/android-29/android.jar --java package/ --manifest app/src/main/AndroidManifest.xml -o package/res.apk</code></li>
</ol>
<ul>
<li>-I：必要参数，指定 android.jar 目录，因为 xml 中可能使用到了例如 android:id 等自带的 android 命名空间</li>
<li>o：指定输出 apk 路径</li>
<li>—java：指定生成的 R 文件的路径</li>
<li>—manifest：必要参数，Manifest 文件中包含了 app 的包名和 application id</li>
</ul>
<p>初步 apk 文件内容包含 resources.arsc 和 AndroidManifest.xml</p>
<ol start="3">
<li>
<p>编译 .java 文件为 .class 文件,再转换成 .dex 文件；生成 classes.dex<br>
<code>javac -encoding utf-8 -target 1.8 -bootclasspath D:/android-sdk-windows/platforms/android-29/android.jar app/src/main/java/com/raise/practice/*.java package/com/raise/practice/R.java -d package/</code><br>
<code>d8 package/com/raise/practice/*.class --classpath D:/android-sdk-windows/platforms/android-29/android.jar --output ./</code></p>
</li>
<li>
<p>将 dex 文件添加进 apk<br>
<code>aapt add package/res.apk classes.dex</code></p>
</li>
<li>
<p>对齐 apk<br>
<code>zipalign 4 package/res.apk package/app-unsigned-aligned.apk</code></p>
</li>
<li>
<p>签名<br>
<code>apksigner sign --ks key.jks --out package/app-release.apk package/app-unsigned-aligned.apk</code></p>
</li>
</ol>
<p>参考：<br>
<a href="http://www.manongjc.com/article/59926.html">APK 的前世今生：从 Android 源码到 apk 的编译打包流程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gradle task 详解（三）]]></title>
        <id>https://raiseyang.github.io/post/gradle-task-xiang-jie-san/</id>
        <link href="https://raiseyang.github.io/post/gradle-task-xiang-jie-san/">
        </link>
        <updated>2017-10-21T09:00:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="projecttaskaction">Project&amp;Task&amp;Action</h3>
<ul>
<li>一个 Gradle 项目由一个或多个 Project 组成.</li>
<li>一个 Project 由一个或多个 Task 组成.</li>
<li>一个 Task 由一个或者多个 Action 组成.</li>
<li>在一个新建的默认的安卓项目中,默认存在2个 Project: <code>project_name(root)</code>,<code>:app</code></li>
<li>setting.gradle 文件仅做配置 project 使用</li>
</ul>
<h3 id="gradle-执行阶段">Gradle 执行阶段</h3>
<p>gradle 运行将会分别执行3个阶段: <code>initialization</code>, <code>configuration</code>, <code>execution</code>.</p>
<ul>
<li><code>initialization</code> 阶段将会识别所有 project.<br>
在 <code>configuration</code> 阶段,会将所有的依赖,配置都同步完成,在 <code>execution</code> 阶段将会使用这些依赖,配置来构建具体任务;<br>
在 <code>configuration</code> 阶段执行完成之后, <code>execution</code> 阶段才会执行;<br>
比如:</li>
</ul>
<pre><code>task testPhase {
	println 'configuration phase exec 1.'
	doFirst {
		println 'execution phase exec a.'
	}
	doLast {
		println 'execution phase exec b.'
	}
	println 'configuration phase exec 2.'
}

</code></pre>
<p><code>doFirst</code> 和 <code>doLast</code> action块都是在 <code>execution</code> 阶段执行,其余代码将会在<code>configuration</code> 执行,所有应该结果应该是 1,2,a,b;<br>
实际运行结果如下:</p>
<pre><code>$ gradle testPhase -q
configuration phase exec 1.
configuration phase exec 2.
execution phase exec a.
execution phase exec b.
</code></pre>
<p>所以在自定义 Task 时,编写的代码需要区分到底是在哪个阶段运行.</p>
<h3 id="task">Task</h3>
<p>一个 task 是一个单一的构建任务,一次 build 任务执行时,通常会执行多个 task, 比如:编译生成 classes,生成 javaDoc 文档等等;<br>
通常我们这样创建 task:</p>
<pre><code>task myTask
task myTask { configure closure }
task myTask(type: SomeType)
task myTask(type: SomeType) { configure closure }
</code></pre>
<p>每个 task 都有一个 name, 上述 task 的 name 为 myTask; 因为 task 和 project 关联,所以每个具体的 task 都有一个全路径,根据所属 project 来指定,使用 <code>:</code> 号分隔;<br>
下例代码,表示一个 clean task 的的执行过程:</p>
<pre><code>Executing tasks: [clean]
:clean
:app:clean
:http_libs:clean
:iot_download_libs:clean
:iot_libs:clean
:mqtt_libs:clean
:trace:clean

BUILD SUCCESSFUL in 1s
7 actionable tasks: 7 executed
</code></pre>
<p>可以发现命名规则为: <code>:project_name:task_name</code><br>
一个 task 属于某个具体的 project 中,不同的 project 通常会包含同一个 task, 比如 build;</p>
<h3 id="task-actions">Task Actions</h3>
<p>一个task由众多 <code>Action</code> 组成,当一个任务执行时,每个 <code>Action</code> 将依次执行;我们也可以自己添加 <code>Action</code>, 最常见的就是 <code>doFirst</code>,<code>doLast</code>;</p>
<pre><code>task clean {
    doFirst {
        println 'custom task:1'
    }
}
</code></pre>
<h3 id="自定义task">自定义task</h3>
<blockquote>
<p>自定义 task 可以在构建项目过程中，做一些自动化的事情：比如属性配置，拷贝文件，执行某段脚本等；</p>
</blockquote>
<p>Gradle DSL 支持 task 代码块，API 也包含一些常用的任务：Copy,Wrapper,exec...，你也可以使用这些任务的一些简单属性来做事情；<br>
比如：<code>Copy</code> 任务包含两个属性：<code>from</code>,<code>into</code>；from 属性可以配置源文件(夹), into 配置目标文件(夹)。</p>
<pre><code>task copyApks(type: Copy) {
    from(&quot;$buildDir/outputs/apk&quot;) {
        exclude '**/*unsigned.apk', '**/*unaligned.apk'
    }
    into '../apks'
}
</code></pre>
<p><code>$buildDir</code> 表示获取当前 project 的 build 目录；<br>
<code>**</code>匹配所有层级目录<br>
<code>*</code>匹配所有字符<br>
注:不要急着去执行该任务,因为我们还不知道该任务何时执行;</p>
<p>如果不想使用 API 包含的任务来配置任务,也可以完全自定义任务;</p>
<pre><code>task printVariantNames() {
    println 'configuration time will exec'
    doLast {
        android.applicationVariants.all { variant -&gt;
            println variant.name
        }
    }
}
</code></pre>
<p>注意 <code>doLast</code> 代码块内的代码会在 <code>execution</code> 阶段执行,而该代码块之外的代码会在 <code>configuration</code> 阶段执行;</p>
<p>上述 task 作用是在打印出所有变体名称;<br>
我们再来看一组示例:</p>
<pre><code>task installDebugFlavors() {
    android.applicationVariants.all { v -&gt;
        if (v.name.endsWith('Debug')) {
            String name = v.name.capitalize()
            dependsOn &quot;install$name&quot;
        }
    }
}
</code></pre>
<p>该 task 作用是安装所有 Debug 任务到设备中(请提前确保应用包名不一致);<br>
<code>dependsOn</code> 方法在 <code>configuration</code> 阶段执行,所有当我们执行该 task 时,先是将所有依赖的任务配置好之后,再分别执行他们;</p>
<pre><code>./gradlew instDebFl
:app:preBuild UP-TO-DATE
:app:preArrogantDebugBuild UP-TO-DATE
:app:checkArrogantDebugManifest
// ... lots of tasks ...
:app:assembleArrogantDebug UP-TO-DATE
:app:installArrogantDebug
Installing APK 'app-arrogant-debug.apk' on 'Nexus_5_API_23(AVD) - 6.0'
Installed on 1 device.
:app:checkFriendlyDebugManifest
// ... lots of tasks ...
:app:assembleFriendlyDebug UP-TO-DATE
:app:installFriendlyDebug
Installing APK 'app-friendly-debug.apk' on 'Nexus_5_API_23(AVD) - 6.0'
Installed on 1 device.
:app:checkObsequiousDebugManifest
// ... lots of tasks ...
:app:assembleObsequiousDebug UP-TO-DATE
:app:installObsequiousDebug
Installing APK 'app-obsequious-debug.apk' on 'Nexus_5_API_23(AVD) - 6.0'
Installed on 1 device.
:app:installDebugFlavors
BUILD SUCCESSFUL
</code></pre>
<h3 id="在-build-阶段运行自定义-task">在 build 阶段运行自定义 task</h3>
<blockquote>
<p>使用 dependOn 属性插入您的任务</p>
</blockquote>
<p>上节拷贝 apk 的 task 是没法运行的,因为在 build 时, apk 可能还没有生成,所以更别谈 copy 了; <code>assemble</code> task 是生成 apk 的任务,所有我们依赖在这个任务上,就可以完成 copy apk 的任务;</p>
<pre><code>task copyApks(type: Copy, dependsOn: assembleDebug) {
        from(&quot;$buildDir/outputs/apk&quot;) {
            exclude '**/*unsigned.apk', '**/*unaligned.apk'
    }
    into '../apks'
}
</code></pre>
<p><code>dependsOn: assembleDebug</code> 使用 dependsOn 可以添加一个前置任务;<br>
如果想要在每次 build 时,都 copy apk, 可以加入下例代码:<br>
<code>build.dependsOn copyApks</code></p>
<h3 id="常用内部任务类型task-types">常用内部任务类型(Task types)</h3>
<h4 id="exec"><a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html">Exec</a></h4>
<pre><code>task stopTomcat(type:Exec) {
  workingDir '../tomcat/bin'

  //on windows:
  commandLine 'cmd', '/c', 'stop.bat'

  //on linux
  commandLine './stop.sh'

  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method stopTomcat.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }
}
</code></pre>
<h4 id="copy"><a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html">Copy</a></h4>
<pre><code>task copyDocs(type: Copy) {
    from 'src/main/doc'
    into 'build/target/doc'
}

//for Ant filter
import org.apache.tools.ant.filters.ReplaceTokens

//for including in the copy task
def dataContent = copySpec {
    from 'src/data'
    include '*.data'
}

task initConfig(type: Copy) {
    from('src/main/config') {
        include '**/*.properties'
        include '**/*.xml'
        filter(ReplaceTokens, tokens: [version: '2.3.1'])
    }
    from('src/main/config') {
        exclude '**/*.properties', '**/*.xml'
    }
    from('src/main/languages') {
        rename 'EN_US_(.*)', '$1'
    }
    into 'build/target/config'
    exclude '**/*.bak'

    includeEmptyDirs = false

    with dataContent
}
</code></pre>
<h4 id="delete"><a href="">Delete</a></h4>
<pre><code>task makePretty(type: Delete) {
  delete 'uglyFolder', 'uglyFile'
  followSymlinks = true
}
</code></pre>
<h3 id="task简写">task简写</h3>
<pre><code>task hello &lt;&lt; {
    println 'Hello world!'
}
</code></pre>
<pre><code>task hello {
    doLast{
        println 'Hello world!'
    }
}
</code></pre>
<h3 id="task依赖">task依赖</h3>
<pre><code>task taskX(dependsOn: 'taskY') {
    doLast {
        println 'taskX'
    }
}
task taskY {
    doLast {
        println 'taskY'
    }
}
</code></pre>
<p><code>dependsOn</code> 指定依赖的任务,上述代码 <code>taskX</code> 依赖 <code>taskY</code>, 执行 <code>taskX</code> 时,会限制性 <code>taskY</code> 任务.<br>
<code>&lt;&lt;</code>操作符为 <code>doLast</code> 简写;以上两种写法效果一样.</p>
<hr>
<p>参考:<br>
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html">Gradle Task</a><br>
https://docs.gradle.org/current/userguide/tutorial_using_tasks.html<br>
<a href="https://docs.gradle.org/4.2.1/userguide/more_about_tasks.html#declareTask">more_about_tasks</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gradle Java 项目构建（二）]]></title>
        <id>https://raiseyang.github.io/post/gradle-java-xiang-mu-gou-jian-er/</id>
        <link href="https://raiseyang.github.io/post/gradle-java-xiang-mu-gou-jian-er/">
        </link>
        <updated>2017-10-21T06:35:32.000Z</updated>
        <content type="html"><![CDATA[<p>通过上一章的内容, 我们了解了 gradle 的基本结构, 这一章通过 Java 项目,更深入的了解.</p>
<h2 id="创建项目文件结构">创建项目文件结构</h2>
<p>创建一个 java-demo 项目</p>
<pre><code>$ mkdir java-demo
$ cd java-demo
</code></pre>
<p>使用 gradle 命令手动创建 Java 目录结构</p>
<pre><code>$ gradle init --type java-application
:wrapper
:init

BUILD SUCCESSFUL in 1s
2 actionable tasks: 2 executed
</code></pre>
<p>构建成功后, 我们看一下目前 java-demo 的目录结构</p>
<pre><code>│  build.gradle
│  gradlew
│  gradlew.bat
│  settings.gradle
│
├─.gradle
│  ...
│
├─gradle
│  └─wrapper
│          gradle-wrapper.jar
│          gradle-wrapper.properties
│
└─src
    ├─main
    │  └─java
    │          App.java
    │
    └─test
        └─java
                AppTest.java
                
</code></pre>
<p><code>build.gradle</code> 为 gradle 脚本文件,每一个 project 都对应一个.<br>
<code>setting.gradle</code>为 gradle setting 文件,该文件仅作为配置 project 使用. 目前我们就一个 project, 可以暂时不理会.<br>
<code>src</code> 为 Java 源码目录, <code>main</code> 为主体代码区, <code>test</code> 为测试代码区.</p>
<h2 id="buildgradle">build.gradle</h2>
<ul>
<li>build.gradle</li>
</ul>
<pre><code>// Apply the java plugin to add support for Java
apply plugin: 'java'

// Apply the application plugin to add support for building an application
apply plugin: 'application'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

dependencies {
    // This dependency is found on compile classpath of this component and consumers.
    compile 'com.google.guava:guava:21.0'

    // Use JUnit test framework
    testCompile 'junit:junit:4.12'
}

// Define the main class for the application
mainClassName = 'App'
</code></pre>
<p><code>repositories</code> 配置一个仓库,所有的依赖都会去该仓库下载.<br>
<code>dependencies</code> 配置该项目需要使用到的jar包<br>
<code>mainClassName</code>, <code>main</code> 方法所在的入口类.<br>
其他文件大家也可以看一下,不过因为增加了 <code>java</code>, <code>application</code> 插件,我们先一下现在有哪些任务可以执行:</p>
<pre><code>$ gradle tasks
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Distribution tasks
------------------
assembleDist - Assembles the main distributions
distTar - Bundles the project as a distribution.
distZip - Bundles the project as a distribution.
installDist - Installs the project as a distribution as-is.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.


Verification tasks
------------------
check - Runs all checks.
test - Runs the unit tests.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed

</code></pre>
<h2 id="run">run</h2>
<p>现有有这么多与 Java 项目相关的任务都可以执行.先执行 <code>run</code> 试试:</p>
<pre><code>$ gradle run
:compileJava
:processResources NO-SOURCE
:classes
:run
Hello world.

BUILD SUCCESSFUL in 3s
2 actionable tasks: 2 executed
</code></pre>
<p>从 gradle 控制台,我们可以发现 gradle 执行了 4 个任务,但我们只运行了一个 <code>run</code> 任务.<br>
原来 gradle 中的 task 之间可以设置依赖关系, run 依赖 <code>classes</code>, <code>classes</code> 依赖 <code>processResourse</code> 和 <code>compileJava</code> 任务,所以被依赖的任务必须先完成才行.这和我们编译运行 Java 代码流程一致:先编译,再运行.</p>
<pre><code class="language-graphLR">    A[:run] --&gt;B(:classes)
    B --&gt;D[:compileJava]
    B --&gt;E[:processResources]
</code></pre>
<p>想要了解更详细的 task 依赖关系可以参考: <a href="https://github.com/dorongold/gradle-task-tree">gradle-task-tree</a></p>
<h2 id="build">build</h2>
<p>使用 <code>build</code> 可以构建整个 Java 项目,将输出很多项目构建时产生的文件.</p>
<pre><code>$ gradle build
:compileJava
:processResources NO-SOURCE
:classes
:jar
:startScripts
:distTar
:distZip
:assemble
:compileTestJava
:processTestResources NO-SOURCE
:testClasses
:test
:check
:build

BUILD SUCCESSFUL in 2s
7 actionable tasks: 7 executed

</code></pre>
<p>运行完成之后,将会在项目根目录下生成 <code>build</code> 目录.<br>
该项目 <code>.jar</code> 文件存放在 <code>build/libs/</code> 目录下.<br>
可以打开 <code>build\reports\tests\test\index.html</code> 文件查看测试报告.</p>
<h2 id="打包-jar">打包 .jar</h2>
<p>当前若只想打包 <code>.jar</code> 文件,只需要执行 <code>gradle jar</code> 即可. 但是这里需要注意打包出来的 jar 包是不能直接运行的, 想要打包可运行的 jar 需要在 build.gradle 中加入:</p>
<pre><code>jar {
    manifest {
        attributes 'Main-Class': 'App'
    }
    archiveName &quot;java-demo.jar&quot;
}
</code></pre>
<p>增加清单文件属性 'Main-class', 属性值为类的全包名 <code>com.raise.xxx.Main</code>.<br>
<code>archiveName</code> 指定jar包的名称.<br>
若注释有中文, 还需要指定编码:</p>
<pre><code>tasks.withType(JavaCompile) {
    options.encoding = &quot;UTF-8&quot;
}
</code></pre>
<p>build 目录不需要我们手动删除,下次构建时会自动删除旧文件.若想清除 build, 可以使用 clean 命令.</p>
<h2 id="clean">clean</h2>
<pre><code>$ gradle clean
:clean

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed

</code></pre>
<p>该命令将会删除当前 project 的 build 目录,若执行该任务失败,也可手动在磁盘上删除 build 目录,不会影响项目构建.</p>
<hr>
<p>参考:<br>
https://guides.gradle.org/building-java-applications/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gradle 环境搭建（一）]]></title>
        <id>https://raiseyang.github.io/post/gradle-huan-jing-da-jian/</id>
        <link href="https://raiseyang.github.io/post/gradle-huan-jing-da-jian/">
        </link>
        <updated>2017-10-21T05:04:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境要求">环境要求</h2>
<p>JDK 1.7+</p>
<h2 id="安装">安装</h2>
<ol>
<li>去<a href="https://gradle.org/releases/">官方网站</a>下载最新版本,目前最新版本为<code>gradle-4.1-milestone-1</code>,下载地址: https://downloads.gradle.org/distributions/gradle-4.1-milestone-1.</li>
<li>解压到 <code>D:</code> 目录下.</li>
<li>配置 <code>GRADLE_HOME</code> 环境变量为:<code>D:\gradle-4.1-milestone-1</code>;并将<code>%GRADLE_HOME%\bin</code>添加到PATH中.</li>
<li>打开命令行窗口,输入下例命令验证 gradle 配置.</li>
</ol>
<pre><code>PS D:\gradle-4.1-milestone-1&gt; gradle -v

------------------------------------------------------------
Gradle 4.1-milestone-1
------------------------------------------------------------

Build time:   2017-06-20 17:05:46 UTC
Revision:     3ad5af92d482b963cc6b00fb5ad53b608606d657

Groovy:       2.4.11
Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015
JVM:          1.8.0_112 (Oracle Corporation 25.112-b15)
OS:           Windows 10 10.0 amd64

PS D:\gradle-4.1-milestone-1&gt;
</code></pre>
<ol start="5">
<li>若出现了上述信息,代表配置成功.</li>
</ol>
<h2 id="hello-world">Hello World!</h2>
<p>新建 build.gradle 文件,并定义一个 task. <code>build.gradle</code> 文件位置: <code>/d/gradle-4.1-milestone-1/gradle-demo/build.gradle</code><br>
运行 <code>gradle tasks</code> 即可查看该project下的所有任务:</p>
<pre><code>/d/gradle-4.1-milestone-1/gradle-demo
$ gradle tasks
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project 'gradle-demo'.
components - Displays the components produced by root project 'gradle-demo'. [incubating]
dependencies - Displays all dependencies declared in root project 'gradle-demo'.
dependencyInsight - Displays the insight into a specific dependency in root project 'gradle-demo'.
dependentComponents - Displays the dependent components of components in root project 'gradle-demo'. [incubating]
help - Displays a help message.
model - Displays the configuration model of root project 'gradle-demo'. [incubating]
projects - Displays the sub-projects of root project 'gradle-demo'.
properties - Displays the properties of root project 'gradle-demo'.
tasks - Displays the tasks runnable from root project 'gradle-demo'.

To see all tasks and more detail, run gradle tasks --all

To see more detail about a task, run gradle help --task &lt;task&gt;

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</code></pre>
<p>在build.gradle文件中,新建一个sayHello任务:</p>
<pre><code>task sayHello {
	doLast {
		println 'Hello World!'
	}
}
</code></pre>
<p>运行sayHello任务,即可打印出Hello World!</p>
<pre><code>$ gradle sayHello
Starting a Gradle Daemon (subsequent builds will be faster)
:sayHello
Hello World!

BUILD SUCCESSFUL in 3s
1 actionable task: 1 executed

</code></pre>
<p><code>:syaHello</code> 为正在执行的任务名称.<br>
<code>Hello World!</code> 为我们输出的字符串.</p>
<h2 id="gradle-wapper">Gradle Wapper</h2>
<p><code>Gradle Wapper</code> 可以使我们在没有安装gralde 的环境下运行 gradle, 而且可以很方便的更换 gradle 的版本.</p>
<pre><code>$ gradle wrapper
:wrapper

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed

/d/gradle-4.1-milestone-1/gradle-demo
$ ls
build.gradle  gradle/  gradlew*  gradlew.bat
</code></pre>
<p><code>gradle/</code> 文件夹下为当前项目的配置文件,可以很方便的修改 gradle 的版本<br>
<code>gradlew</code>, <code>gradlew.bat</code> 为 unix, windows 系统下的脚本文件, 可以直接运行 gradle 脚本.<br>
比如运行上述 sayHello 任务(注意使用 <code>gradlew</code> ):</p>
<pre><code>$ ./gradlew sayHello
Downloading https://services.gradle.org/distributions/gradle-4.1-milestone-1-bin.zip
</code></pre>
<blockquote>
<p>注: 第一次运行, 将会下载 <code>PROJECT_ROOT/gradle/wrapper/gradle-wrapper.properties</code> 文件中配置的 gradle 版本,可能时间会比较长.</p>
</blockquote>
<p>以后执行 gradle 指令就可以使用 <code>gradlew task_name</code>, 记得提前进入项目根目录.</p>
<h2 id="运行一个核心任务core-task">运行一个核心任务(core task)</h2>
<p>Gradle 内置了很多 type,供创建 task 时使用,比如 <code>Copy</code>, 他的作用是拷贝文件.<br>
新建文件夹 src, 并在 src 下建立一个文件 hello.txt, 运行下述任务:</p>
<pre><code>task copy(type: Copy) {
    from 'src'
    into 'dest'
}
</code></pre>
<p>将会生成 dest 文件夹,并拷贝 hello.txt 文件至 dest 文件夹下.</p>
<h2 id="使用-gradle-插件">使用 gradle 插件</h2>
<p>目前我们项目只有最基础的 gradle 构建能力,并不能构建一个 Java 项目,或者 android 项目.</p>
<pre><code>$ gradle tasks --all
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------
...

Other tasks
-----------
copy
sayHello

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</code></pre>
<p>只有我们定义的 2 个基础方法, 并且这两个方法对一个具体的项目没有什么作用.<br>
那么如何构建一个 Java 项目的 gradle 呢, 这就使用的 gradle plugin 的概念. gradle plugin 中定义了众多任务,使得我们构建某个具体的项目变得简单.<br>
比如 <code>java</code> 插件可以构建 Java 项目</p>
<pre><code>plugins {
    id 'java'
}
</code></pre>
<p>我们再来看现在 gradle 有哪些任务:</p>
<pre><code>$ gradle tasks --all
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Build tasks
-----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

Help tasks
----------
...

Verification tasks
------------------
check - Runs all checks.
test - Runs the unit tests.

Other tasks
-----------
compileJava - Compiles main Java source.
compileTestJava - Compiles test Java source.
copy
processResources - Processes main resources.
processTestResources - Processes test resources.
sayHello

BUILD SUCCESSFUL in 2s
1 actionable task: 1 executed
</code></pre>
<p><code>java</code> 插件内增加了 <code>Build Tasks</code> 任务集,里面的 <code>jar</code> 任务用来打包 jar 包, <code>assemble</code> 任务用来输出所有文件.</p>
]]></content>
    </entry>
</feed>